Index: base/0_environment.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/base/0_environment.py b/base/0_environment.py
new file mode 100644
--- /dev/null	(date 1698579624000)
+++ b/base/0_environment.py	(date 1698579624000)
@@ -0,0 +1,7 @@
+"""
+Настройка окружения
+"""
+
+# Установить нужную версию Python;
+# Создать виртуальное окружение;
+# Работа с зависимостями (pip list, pip freeze, pip install/uninstall);
Index: base/1_base_syntax.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/base/1_base_syntax.py b/base/1_base_syntax.py
new file mode 100644
--- /dev/null	(date 1698579624000)
+++ b/base/1_base_syntax.py	(date 1698579624000)
@@ -0,0 +1,178 @@
+"""
+Базовый синтаксис
+"""
+import typing
+
+
+# основные типы и структуры
+types = [
+    ...,
+    None,
+    True, False, bool,
+    1, int,
+    1.1, float,
+    ' ', " ", """ """, f'', r'', str,
+    b'', bytes,
+    [], list,
+    (), tuple,
+    {1, }, set,
+    {}, dict
+]
+
+
+# основные операторы
+_ = 1 + 2
+_ = 1 - 2
+_ = 1 * 2
+_ = 1 ** 2
+_ = 1 / 2
+_ = 1 // 2
+_ = 1 % 2
+_ = 1 and 2
+_ = 1 or 2
+_ = 1 > 2 | 1 >= 2 | 1 < 2 | 1 <= 2
+
+
+# цикл for
+for _ in types:
+    pass
+
+for _ in types:
+    break
+else:
+    pass
+
+
+# Comprehensions
+a = [i for i in types]
+b = (i for i in types)
+c = {i for i in types if isinstance(i, typing.Hashable)}
+d = {str(i): i for i in types}
+
+
+# Присвоение, распаковка, срезы
+e, *f, g = types
+h = [*f]
+_ = [1, 2, 3][:]
+_ = {**{}}
+
+
+# Утверждение assert
+assert h, 'test'
+
+
+# цикл while
+while a:
+    a.pop()
+
+while a:
+    break
+else:
+    pass
+
+
+# Функции
+def func(text: str, space: str, action: typing.Callable) -> None:
+    if not text:
+        return
+
+    print(space + action(text))
+    func(text[1:], space + ' ', action)
+    print(space + action(text))
+
+
+# lambda функции
+func('*' * 11, '', lambda text: ' '.join(i for i in text))
+
+
+# Декораторы
+def decorator(multiplier: int):
+
+    def dec(func: typing.Callable):
+        # Области видимости функции
+        global a, b, c, d
+        nonlocal multiplier
+
+        if multiplier % 2 == 0:
+            multiplier += 1
+
+        def wrap(*args, **kwargs):
+            for _ in range(multiplier):
+
+                # Генераторы
+                yield func(*args, **kwargs)
+
+        return wrap
+
+    return dec
+
+
+@decorator(10)
+def f(num: int) -> int:
+    return num
+
+
+qwe = [*f(1)]
+
+
+# Условия
+if i := d.get(''):
+    pass
+elif not (q := d.get(1)):
+    pass
+else:
+    ...
+
+
+# match qwe:
+#     case "1":
+#         pass
+#     case _:
+#         pass
+
+
+# Исключения и их обработка
+try:
+    1 / 0
+except ZeroDivisionError as exc:
+    pass
+else:
+    pass
+finally:
+    ...
+
+
+# Классы
+class A:
+
+    class_attrs = None
+
+    def __init__(self, *args, **kwargs):
+        self.args, self.kwargs = args, kwargs
+        self.__test_arg = None
+
+    def main(self) -> None:
+        ...
+
+    @property
+    def test_arg(self) -> typing.Any:
+        return self.__test_arg
+
+    @test_arg.setter
+    def test_arg(self, value: typing.Any):
+        self.__test_arg = value
+
+
+class B(A):
+
+    def main(self) -> None:
+        super().main()
+        print(self.test_arg)
+
+    @classmethod
+    def create(cls, *args, **kwargs) -> 'B':
+        return cls(*args, **kwargs)
+
+    @staticmethod
+    def get_test() -> str:
+        return 'test'
Index: base/2_structures.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/base/2_structures.py b/base/2_structures.py
new file mode 100644
--- /dev/null	(date 1698579624000)
+++ b/base/2_structures.py	(date 1698579624000)
@@ -0,0 +1,44 @@
+"""
+Основные структуры данных
+"""
+# 1. Как создать / изменить / удалить
+# 2. Изменяемые / неизменяемые объекты
+# 3. Основные методы базовых структур
+a = []
+a = list()
+a = [1] * 10
+a = [1, 2, 3] + [3, 4, 5]
+a = [*a]
+a.append(a)
+a.pop()
+a.extend(a)
+# ...
+
+b = (1, 2, a)
+b = tuple([1, 2])
+b = b[:]
+b, _ = b
+# ...
+
+c = {1, 2}
+d = set([1, 2])
+c.add(3)
+c.remove(3)
+c.update({None, })
+_ = c - d
+_ = c | d
+_ = c & d
+_ = frozenset(c)
+# ...
+
+d = dict(none123=None)
+d = {None: None, **d}
+d[1] = 1
+d = d | {2: 2}
+_ = d.setdefault(3, 3)
+_ = d.get(4)
+d.pop(1)
+d.items()
+d.keys()
+d.values()
+# ...
Index: base/3_work_with_different.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/base/3_work_with_different.py b/base/3_work_with_different.py
new file mode 100644
--- /dev/null	(date 1698579624000)
+++ b/base/3_work_with_different.py	(date 1698579624000)
@@ -0,0 +1,89 @@
+"""
+Работа с разными форматами:
+- работа со временем и датами
+- работа с Decimal
+- работа с регулярными выражениями
+- работа с файлами (например csv)
+- Работа с вводом/выводом
+- Работа с uuid
+- Работа с os
+- Работа с кодировками
+"""
+import csv
+import datetime
+import decimal
+import json
+import os
+import re
+import time
+import uuid
+
+
+# Даты
+today = datetime.date.today()
+yesterday = today - datetime.timedelta(days=1)
+tomorrow = today + datetime.timedelta(days=1)
+
+current_time = datetime.datetime.now()
+current_timestamp = current_time.timestamp()
+in_str = current_time.strftime('%d:%m:%y %H:%M:%S')
+in_datetime = datetime.datetime.strptime(in_str, '%d:%m:%y %H:%M:%S')
+
+timestamp = time.time()
+from_timestamp = datetime.datetime.fromtimestamp(timestamp)
+
+
+# работа с Decimal
+context = decimal.getcontext()
+context.rounding = decimal.ROUND_DOWN
+
+a = decimal.Decimal('0.3')
+b = decimal.Decimal(0.3)
+c = b.quantize(decimal.Decimal('.0001'), rounding=decimal.ROUND_UP)
+
+
+# работа с регулярными выражениями
+pattern = re.compile(r'^@(\w+)$')
+nicknames = ['@qweqwe', '@@qweqwe', 'qweqwe', 'qwe@qwe']
+valid_nicknames = [i for i in nicknames if re.match(pattern, i)]
+
+
+# Работа с файлами
+# some_dict = {'qwe': 123}
+# file_name = 'new.json'
+file_name = 'new.csv'
+with open(file_name, 'w') as file:
+    # json.dump(some_dict, fp=file, indent=4, ensure_ascii=False)
+    fieldnames = ['nicknames', 'length']
+    writer = csv.DictWriter(file, fieldnames=fieldnames)
+    writer.writeheader()
+    for nickname in valid_nicknames:
+        writer.writerow({'nicknames': nickname, 'length': len(nickname)})
+
+with open(file_name, 'r') as file:
+    # json_obj = json.load(file)
+    reader = csv.DictReader(file)
+    for row in reader:
+        print(row['nicknames'], row['length'])
+
+
+# Ввод/вывод
+test = input('test:').split()
+for i in range(10):
+    print(*test, sep='(╯ ° □ °) ╯ ┻━┻', end='\n' + '\t' * i,)
+
+
+# Работа с uuid
+uid = uuid.uuid4()
+
+
+# Работа с os
+path = os.path.join(__file__, 'qweqwe')
+os.getenv('ENV_NAME')
+
+os.system('echo 123')
+
+
+# Кодировки
+a = 'qweqwe'.encode('utf-16')
+b = a.decode('utf-16')
Index: base/4_oop.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/base/4_oop.py b/base/4_oop.py
new file mode 100644
--- /dev/null	(date 1698579624000)
+++ b/base/4_oop.py	(date 1698579624000)
@@ -0,0 +1,77 @@
+"""
+ООП. Классы и наследование, super, магические методы и т.п.
+"""
+import typing
+
+
+class A:
+
+    class_attrs = None
+
+    def __init__(self, *args, **kwargs):
+        self.args, self.kwargs = args, kwargs
+        self.__test_arg = None
+
+    def __len__(self) -> int:
+        return len(self.args) + len(self.kwargs)
+
+    def __bool__(self) -> bool:
+        return bool(self.__test_arg)
+
+    def main(self) -> None:
+        print('Вызов внутри: A')
+
+    @property
+    def test_arg(self) -> typing.Any:
+        return self.__test_arg
+
+    @test_arg.setter
+    def test_arg(self, value: typing.Any):
+        self.__test_arg = value
+
+
+class B(A):
+
+    def main(self) -> None:
+        print('Вызов внутри: B до super')
+        super().main()
+        print('Вызов внутри: B после super')
+
+    @classmethod
+    def create(cls, *args, **kwargs) -> 'B':
+        return cls(*args, **kwargs)
+
+    @staticmethod
+    def get_test() -> str:
+        return 'test'
+
+
+class C(B):
+
+    def main(self) -> None:
+        print('Вызов внутри: C до super')
+        super().main()
+        print('Вызов внутри: C после super')
+
+
+class D(A):
+
+    def main(self) -> None:
+        print('Вызов внутри: D до super')
+        super().main()
+        print('Вызов внутри: D после super')
+
+
+class QWE(C, D):
+
+    def main(self) -> None:
+        print('Вызов внутри: QWE до super')
+        super().main()
+        print('Вызов внутри: QWE после super')
+
+
+if __name__ == '__main__':
+    qwe = QWE()
+    qwe.main()
+    print(QWE.mro())
+    print(dir(QWE))
Index: base/5_tests.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/base/5_tests.py b/base/5_tests.py
new file mode 100644
--- /dev/null	(date 1698579624000)
+++ b/base/5_tests.py	(date 1698579624000)
@@ -0,0 +1,60 @@
+"""
+Написание тестов
+"""
+# Юнит тесты
+
+import unittest
+
+
+def add(x, y):
+    return x + y
+
+
+class TestAdd(unittest.TestCase):
+    """Тестирование функции add."""
+
+    def test_add_positive_numbers(self):
+        result = add(2, 3)
+        self.assertEqual(result, 5)
+
+    def test_add_negative_numbers(self):
+        result = add(-2, -3)
+        self.assertEqual(result, -5)
+
+    def test_add_zero(self):
+        result = add(0, 5)
+        self.assertEqual(result, 5)
+
+    def test_add_negative_and_positive(self):
+        result = add(-2, 5)
+        self.assertEqual(result, 3)
+
+    def test_add_zero_and_zero(self):
+        result = add(0, 0)
+        self.assertEqual(result, 0)
+
+    def test_add_large_numbers(self):
+        result = add(999999999, 1)
+        self.assertEqual(result, 1000000000)
+
+    def test_add_floats(self):
+        result = add(1.2, 3.4)
+        self.assertAlmostEqual(result, 4.6)
+
+    def test_add_string(self):
+        with self.assertRaises(TypeError):
+            add('one', 2)
+
+    def test_add_none(self):
+        with self.assertRaises(TypeError):
+            add(None, 2)
+
+    def test_add_boolean(self):
+        result1 = add(True, 2)
+        result2 = add(False, 4)
+        self.assertEqual(result1, 3)
+        self.assertEqual(result2, 4)
+
+
+if __name__ == '__main__':
+    unittest.main()
Index: base/6_logging.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/base/6_logging.py b/base/6_logging.py
new file mode 100644
--- /dev/null	(date 1698579624000)
+++ b/base/6_logging.py	(date 1698579624000)
@@ -0,0 +1,64 @@
+"""
+Логирование
+"""
+import logging
+import requests
+
+import secrets
+
+
+class TelegramHandler(logging.Handler):
+    """Handler для отправки логов в телеграм."""
+
+    def __init__(self, token, chat_id):
+        super().__init__()
+
+        self.token = token
+        self.chat_id = chat_id
+
+    def send_message_to_telegram(self, message: str) -> None:
+        """Отправляет сообщение в телеграм."""
+        url = f'https://api.telegram.org/bot{self.token}/sendMessage'
+        data = {
+            'chat_id': self.chat_id,
+            'text': message
+        }
+        requests.post(url=url, json=data)
+
+    def emit(self, record: logging.LogRecord) -> None:
+        """
+        Зарегистрировать запись лога.
+
+        Данный метод защищён от возможных ошибок, чтобы ошибка при логировании не повлияла на работу кода.
+        """
+        try:
+            message = self.format(record)
+            self.send_message_to_telegram(message)
+        except RecursionError:
+            raise
+        except Exception:
+            self.handleError(record)
+
+
+def create_tg_logger(name: str) -> logging.Logger:
+    """Создать telegram Logger."""
+    logger = logging.getLogger(name)
+    logger.setLevel(level=logging.DEBUG)
+    handler = TelegramHandler(secrets.TOKEN, secrets.CHAT_ID)
+    handler.formatter = logging.Formatter('%(levelname)s: LOGGER: %(name)s TIME: %(asctime)s: MESSAGE: %(message)s')
+    logger.addHandler(handler)
+
+    return logger
+
+
+def main() -> None:
+    """Тестовое логирование."""
+    logger = create_tg_logger('test-logger')
+
+    print('До')
+    logger.critical('qweqwe, ой беда все сюда')
+    print('После')
+
+
+if __name__ == '__main__':
+    main()
Index: base/7_code.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/base/7_code.py b/base/7_code.py
new file mode 100644
--- /dev/null	(date 1698579624000)
+++ b/base/7_code.py	(date 1698579624000)
@@ -0,0 +1,30 @@
+"""
+Соблюдение общих норм для написания красивого кода, который легко читать и поддерживать.
+"""
+
+# 1) Соблюдение PEP8.
+# 2) Длина строки — 119 символов.
+# 3) Импорты отсортированы правильно, неиспользуемых импортов нет.
+# 4) Отступы — 4 пробела.
+# 5) Одинаковые кавычки, одинаковые методы решения одинаковых проблем.
+# 6) Отсутствие закомментированного кода и стандартных комментариев.
+# 7) Комментарии к функциям оформлены в виде Docstrings.
+# 8) Длинные куски кода логически разделены пустыми строками, как абзацы в тексте.
+# 9) Исполняемый код в .py-файлах закрыт конструкцией if __name__ == ‘__main__’
+# 10) В f-строках применяется только подстановка переменных. Не применяются логические или арифметические операции.
+# 11) Переменные названы в соответствии с их смыслом, по-английски, нет однобуквенных названий и транслита.
+
+
+# Проектирование
+# YAGNI You Aren’t Gonna Need It / Вам это не понадобится
+# Неиспользуемый код удаляется, а не комментируется или висит мёртвым грузом
+
+# DRY Don’t Repeat / Не повторяйтесь
+# Не должно быть одинаковых классов / функций / больших кусков кода, делающих одно и то же
+
+# KISS Keep It Simple, Stupid / Будь проще
+# Нужно стремиться писать максимально простой и понятный код.
+# Каждая функция и класс ориентированы на выполнение одной конкретной задачи
+
+# Есть еще SOLID и DI
+# но это необязательно для нашего уровня (уровень поиска первой работы)
Index: base/8_debugger.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/base/8_debugger.py b/base/8_debugger.py
new file mode 100644
--- /dev/null	(date 1698579624000)
+++ b/base/8_debugger.py	(date 1698579624000)
@@ -0,0 +1,3 @@
+"""
+Навык отладки
+"""
Index: base/secrets.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/base/secrets.py b/base/secrets.py
new file mode 100644
--- /dev/null	(date 1698579624000)
+++ b/base/secrets.py	(date 1698579624000)
@@ -0,0 +1,5 @@
+import os
+
+
+TOKEN = os.getenv('TOKEN')  # Токен телеграм-бота
+CHAT_ID = os.getenv('CHAT_ID')  # Айди чата, где находится телеграм-бот
